\thispagestyle{fancy}
\chapter{Testapplikation}
I dette kapitel vil Testapplikationen til anvendelsen af systemet være beskrevet. Denne er udviklet ud fra kravspecifikationen\todokr{indsæt reference til kravspecifikation}, der har dannet grundlag for applikationens funktionalitet.\\
Det er fra starten af projektet besluttet at applikationen til systemet udvikles i Windows Presentation Foundation (WPF) i Microsoft Visual Studio, da dette er et allerede kendt framework, og det er derfor hurtigt at starte udviklingen.

Denne applikation stiller krav til anvendelsen af den opsamlede data og den model træning der er udviklet. Applikationen skal være i stand til at åbne og lukke CrustCrawler-kloen ved hjælp af genkendelse af poses med Myo'en. WPF er også valgt til udviklingen da det indeholder gode væktøjer til arbejde med GUI, hvilket gør at brugeren af applikationen nemt kan avende systemets funktioner.

\section{Software arkitektur}
Det er valgt til CrustCrawler Applikationen, som testapplikationen hedder, at den skal udvikles i en MVVM\footnote{Model-View-ViewModel} \cite{mvvm} arkitektur. MVVM er et WPF design pattern, der er brugt i mange applikationer med grafisk brugergrænseflade. Dette er et naturligt valg da der udvikles på en XAML platform. .xaml filen er view'et og det bliver muligt at separere view og model-laget med en ViewModel. MVVM er et design pattern der blev udviklet hos microsoft ud fra Model-View-Presenter arkitekturen.Det er i modellen at applikationens funktionaliteten ligger. De er begge koblet sammen af en ViewModel. Dette gør udviklingen af applikationen mere overskuelig og nem at gå til.

\myFigure{MVVM}{Den implementerede arkitektur i applikationen. View'et er adskildt fra modellen med en ViewModel. Modellen er delt op i flere klasser for at opfylde SOLID\cite{SOLID} pricipperne hvor det giver mening i applikationen}{fig:mvvm}{1}

På figur \ref{fig:mvvm} ses den overordnede struktur i hvordan klasserne er placeret. Denne figur er for at give et lille overblik, og der er derfor ikke taget alle klasser med. Modellen som består af flere forskellige klasser er altså vha. MVVM separeret fra viewet som er .xaml-filen MainWindow.xaml.\\
Under udviklingen er der taget højde for SOLID pricipperne, herunder Single Responsebility \cite{SingleRespons}, og dermed er klasser opdelt i projektet sådan at de har hvert deres ansvar. Matlab.cs sørger for alt kommunikation med matlab, hvilket er herigennem der sendes kommandoer til CrustCrawleren, dette er der beskrevet mere om i afsnit \ref{sec:ktc}. I denne klasse initialiseres og startes matlab, og kommandoer sendes også til Matlab herfra. CCManagement.cs, er her metoderne til de forskellige kommandoer kan kaldes fra. Der kaldes fx. metoden OpenClaw() når CrustCrawler kloen skal åbnes. CCManagement.cs Kalder matlab.cs som sender kommando til Matlab. I Klassen Recognition startes genkendelsesmetoderne der vil sørge for at igennem klassen Matlab og få MATLAB serveren\todokr{Ikke færdig}

\section{Brugergrænseflade}

\myWrapFigure{CCA}{CrustCrawler Applikationens GUI}{fig:cca}{0.4}{r}
GUI'en i applikationen er lavet meget simpel. Den bærer præg af at være til for at teste systemet. Figur \ref{fig:cca} viser applikationens GUI. Den giver adgang til nogle forskellige funktionaliteter, bl.a. startes der med at checke orineteringen på armbåndet. Dette giver mulighed for at bære Myo'en med en hvilken som helst orinetering, bare den er blevet checket når Myo'en er påført. For at kunne teste, er der blevet lavet Open Claw og Close Claw knapper, så det hurtig og nemt er muligt at se om der er forbindelse til CrustCrawleren. Det er i sektion \ref{sec:ktc} forklaret hvordan der kommunikeres ud til CrustCrawleren.

Knapperne Sart og stop recognition er her hvor den egentligt anvendelse af den opsamlede data og de udviklede modeller foregår. Ved tryk på "Start Recognition" vil "Window Count" og "Current Window" begynde at tælle op. Ét vindue er sekvens af samples, der genkendes ud fra. "Window Count" er alle de vinduer der er samlet med samples, mens "Current Window" er det aktuelle vindue der bliver genkendt på.

\section{Genkendelse}
For der kan genkendes håndtryk skal der være noget at stille de data op i mod, som kommer fra Myo'en. Det er her alt den opsamlede data der er trænet en model på bruges. Dataen der kommer direkte fra myoen, bliver sendt fra applikationen sat op imod den trænede model der er blevet gennemgået i kapitel \ref{chp:mlm}, og der bliver set på hvilken den mest ligner. 

\myFigure{SekvensDiagramRecognition}{Flow der gennemgåes ved start af genkendelse. Ved tryk på Start Recognition, sendes command til ViewModel der Starter recognition i Recognition klassen, som laver genkendelsen på signalerne fra Myo'en. Alt efter hvilken pose der genkendes, vil CCManagement lytte hertil og kalde funktionen der matcher genkendelsen.}{fig:sdr}{1}



\section{Kommunikation med CrustCrawler}
\label{sec:ktc}
Som nævnt tidligere foregår alt kommunikation med CrustCrawleren igennem matlab klassen. Her sørges der for at kalde funktioner i en MATLAB Automation server\footnote{Fremover nævnt som MATLAB server} der bliver åbnet under initieringen af matlab klassen. kald der bliver lavet i MATLAB serveren er både når der skalsende Myo data til genkendelse, men også når der kaldet funktioner til at manøvrere CrustCrawleren. På sekvens diagrammet på figur \ref{fig:sd} ses de kald der bliver foretaget i tilfældet at kloen på CrustCrawleren skal åbnes.

\myFigure{Sekvensdiagram}{OpenClaw() i CCManagement klassen kaldes, som kontakter Matlab.cs da der skal kontakt til MATLAB serveren. MATLAB serveren bliver kaldt og i MATLAB er der udviklet funktioner til at manøvrere CrustCrawleren rundt og styre kloen. Funktionen OpenClaw() i MATLAB serveren kalder funktionen MoveServo(), denne skriver ud til CrustCrawleren at servo nummer 7 skal køre til en bestemt anvist position.}{fig:sd}{1}

Processen for at kunne kalde funktioner lavet i MATLAB fra WPF applikationen foregår som følger \cite{MatlabC}:
\begin{enumerate}
%	\itemsep -0.9em 
	\item Start MATLAB Automation Server og lav en instans heraf
	\item Set sti til mappe hvor MATLAB funktioner ligger
	\item Der kan nu Kaldes funktioner lavet i MATLAB
\end{enumerate}

\myWrapFigure{USB2Dynamixel}{USB2Dynamixel enhed der bruges for at lave en seriel port fra en af computerens USB porte. Igennem USB2Dynamixel kan CrustCrawleren tilkobles computeren.}{fig:usb2d}{0.4}{r}

CrustCrawleren tilkobles computeren gennem en USB2Dynamixel, se figur \ref{fig:usb2d}. USB2Dynamixel er brugt for at lave en seriel port igennem computerens USB port. Til denne er en driver og et .dll bibliotek, med en tilhørende headerfil. Dynamixel.dll og dynamixel.h. Disse filer loades begge i MATLAB koden, hvor biblioteket giver mulighed for at kalde nogle forskellige funktioner som CrustCrawleren kan reagere på. Driveren er\\ USB2Dynamixel \cite{usb2dynamixel} \todokr{lav reference til manual hvis denne laves} og er frit tilgængelig for alle, kan dog kun bruges med en USB2Dynamixel enhed, og Dynamixel servoer.

\section{Delkonklusion}
Det er nu muligt som bruger med denne applikation og en Myo at genkende håndtrykkene åben hånd og lukket hånd, vha. en trænet machine learning model. Applikationen står for at få data fra Myo'en og sende det til en MATLAB server, hvor der beregnes, og sammenlignes med den trænede model, og der sendes resultat tilbage til applikationen. Genkendelsen anvendes på en CrustCrawler robot arm, der åbnet og lukkes alt efter genkendelsen.